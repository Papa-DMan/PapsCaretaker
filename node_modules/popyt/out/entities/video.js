"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Video = void 0;
const util_1 = require("../util");
/**
 * A YouTube video.
 */
class Video {
    constructor(youtube, data) {
        this.youtube = youtube;
        this.data = data;
        this._init(data);
    }
    /**
     * @ignore
     */
    _init(data) {
        if (data.kind === 'youtube#video') {
            const video = data;
            /* istanbul ignore next */
            if (video.contentDetails) {
                this._length = util_1.Parser.parseIsoDuration(video.contentDetails.duration);
                this.minutes = (this._length.hours * 60) + this._length.minutes;
                this.seconds = this._length.seconds;
            }
            else {
                this.full = false;
            }
            /* istanbul ignore next */
            if (video.statistics) {
                this.likes = Number(video.statistics.likeCount);
                this.dislikes = Number(video.statistics.dislikeCount);
                this.views = Number(video.statistics.viewCount);
                this.commentCount = Number(video.statistics.commentCount);
            }
            else {
                this.full = false;
            }
            this.id = video.id;
        }
        else if (data.kind === 'youtube#playlistItem') {
            this.full = false;
            this.id = data.snippet.resourceId.videoId;
            this.private = data.snippet.title === 'Private video';
        }
        else if (data.kind === 'youtube#searchResult') {
            this.full = false;
            this.id = data.id.videoId;
        }
        else {
            throw new Error(`Invalid video type: ${data.kind}`);
        }
        /* istanbul ignore next */
        if (data.snippet) {
            this.title = data.snippet.title;
            this.description = data.snippet.description;
            this.thumbnails = data.snippet.thumbnails;
            this.tags = data.snippet.tags;
            this.datePublished = new Date(data.snippet.publishedAt);
            this.channelId = data.snippet.channelId;
            // Impossible to test
            /* istanbul ignore next */
            this.liveStatus = data.snippet.liveBroadcastContent !== 'none' ? data.snippet.liveBroadcastContent : false;
            this.category = data.snippet.categoryId;
        }
        else {
            this.full = false;
        }
        /* istanbul ignore next */
        if (data.status) {
            this.private = data.status.privacyStatus === 'private';
            this.kids = {
                madeForKids: data.status.madeForKids,
                selfDeclaredMadeForKids: data.status.selfDeclaredMadeForKids
            };
        }
        else {
            this.full = false;
        }
        this.url = `https://youtube.com/watch?v=${this.id}`;
        this.shortUrl = `https://youtu.be/${this.id}`;
        return this;
    }
    /**
     * Posts a comment to the video.
     * Must be using an access token with correct scopes.
     * @param text The text of the comment.
     */
    /* istanbul ignore next */
    postComment(text) {
        return __awaiter(this, void 0, void 0, function* () {
            const comment = yield this.youtube.oauth.postComment(text, this.channelId, this.id);
            if (this.comments !== undefined) {
                this.comments.push(comment);
            }
            else {
                this.comments = [comment];
            }
            return comment;
        });
    }
    /**
     * Fetches this video and reassigns this object to the new video object.
     * Only useful if `this.full` is false, or if you want updated video info.
     */
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            const video = yield this.youtube.getVideo(this.id);
            return Object.assign(this, video);
        });
    }
    /**
     * Fetches the video's comments and assigns them to Video#comments.
     * @param maxResults The maximum amount of comments to fetch
     */
    fetchComments(maxResults = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            this.comments = yield this.youtube.getVideoComments(this.id, maxResults);
            return this.comments;
        });
    }
    /**
     * Gets the user's rating on the video.
     */
    /* istanbul ignore next */
    getRating() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.youtube.oauth.getMyRatings([this.id]);
            return response[0].rating;
        });
    }
    /**
     * Likes the video.
     * Must be using an access token with correct scopes.
     */
    /* istanbul ignore next */
    like() {
        return this.youtube.oauth.rateVideo(this.id, 'like');
    }
    /**
     * Dislikes the video.
     * Must be using an access token with correct scopes.
     */
    /* istanbul ignore next */
    dislike() {
        return this.youtube.oauth.rateVideo(this.id, 'dislike');
    }
    /**
     * Removes the user's like/dislike on the video.
     * Must be using an access token with correct scopes.
     */
    /* istanbul ignore next */
    unrate() {
        return this.youtube.oauth.rateVideo(this.id, 'none');
    }
    /**
     * Reports the video for abuse.
     * Must be using an access token with correct scopes.
     * @param reasonId The reason for reporting. (IDs can be found [here](https://developers.google.com/youtube/v3/docs/videoAbuseReportReasons/list))
     * @param secondaryReasonId An optional second reason for reporting.
     * @param comments Any additional information.
     * @param language The language that the reporter speaks.
     */
    /* istanbul ignore next */
    reportAbuse(reasonId, secondaryReasonId, comments, language) {
        return this.youtube.oauth.reportAbuse(this.id, reasonId, secondaryReasonId, comments, language);
    }
    /**
     * Deletes the video.
     * Must be using an access token with correct scopes.
     */
    /* istanbul ignore next */
    delete() {
        return this.youtube.oauth.deleteVideo(this.id);
    }
    /**
     * Edits the video.
     * Must be using an access token with correct scopes.
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * @param video The updated video object.
     */
    /* istanbul ignore next */
    update(video) {
        return __awaiter(this, void 0, void 0, function* () {
            const newVideo = yield this.youtube.oauth.updateVideo(video);
            return Object.assign(this, Object.assign(Object.assign({}, newVideo), { full: true }));
        });
    }
    /**
     * Sets a new thumbnail for a video.
     * Must be using an access token with correct scopes.
     * @param image The image data and type to upload.
     */
    /* istanbul ignore next */
    setThumbnail(image) {
        return __awaiter(this, void 0, void 0, function* () {
            const newThumbnails = yield this.youtube.oauth.setThumbnail(this.id, image);
            return Object.assign(this.thumbnails, newThumbnails);
        });
    }
    /**
     * Fetches the captions for the video.
     * Must be using an access token with correct scopes.
     */
    /* istanbul ignore next */
    fetchCaptions() {
        return __awaiter(this, void 0, void 0, function* () {
            this.captions = yield this.youtube.oauth.getCaptions(this.id);
            return this.captions;
        });
    }
    /**
     * Uploads a caption track for a video.
     * Must be using an access token with correct scopes.
     * @param language The language of the track.
     * @param name The name of the track.
     * @param track The caption track to upload.
     * @param draft Whether or not the track is a draft.
     */
    /* istanbul ignore next */
    uploadCaption(language, name, track, draft = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const toReturn = yield this.youtube.oauth.uploadCaption(this.id, language, name, track, draft);
            return toReturn;
        });
    }
    /**
     * Updates a caption track of a video.
     * Must be using an access token with correct scopes.
     * @param track The modified caption track to upload.
     * @param draft Whether or not the track is a draft.
     */
    /* istanbul ignore next */
    updateCaption(track, draft = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const toReturn = yield this.youtube.oauth.updateCaption(this.id, track, draft);
            return toReturn;
        });
    }
}
exports.Video = Video;
/**
 * The name of the endpoint used for this entity.
 */
Video.endpoint = 'videos';
/**
 * The parts to request for this entity.
 */
Video.part = 'snippet,contentDetails,statistics,status';
/**
 * The fields to request for this entity.
 */
Video.fields = 'items(kind,id,contentDetails(duration),statistics(likeCount,dislikeCount,viewCount,commentCount),' +
    'status(privacyStatus,madeForKids,selfDeclaredMadeForKids),snippet(title,description,thumbnails,tags,publishedAt,channelId,liveBroadcastContent,categoryId))';

//# sourceMappingURL=video.js.map
