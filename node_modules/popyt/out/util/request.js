"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Request = void 0;
const https_1 = require("https");
const url_1 = require("url");
/**
 * @ignore
 */
/* istanbul ignore next */
class Request {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }
    api(subUrl, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        return this.get(url, accessToken);
    }
    post(subUrl, params, data, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        return this._post(url, data, accessToken);
    }
    put(subUrl, params, data, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        return this._put(url, data, accessToken);
    }
    delete(subUrl, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        return this._delete(url, accessToken);
    }
    imagePost(subUrl, image, imageType, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        return this._post(url, image, accessToken, `image/${imageType}`);
    }
    streamPut(subUrl, stream, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        return this._put(url, stream, accessToken, 'application/octet-stream');
    }
    multipartStreamPost(subUrl, data, extraData, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        const boundary = this.generateBoundary();
        return this._postMultipart(url, data, extraData, accessToken, 'application/json', 'application/octet-stream', boundary);
    }
    multipartImagePost(subUrl, data, image, imageType, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        const boundary = this.generateBoundary();
        return this._postMultipart(url, data, image, accessToken, 'application/json', `image/${imageType}`, boundary);
    }
    multipartStreamPut(subUrl, data, extraData, params, token, accessToken) {
        const url = this.formUrl(subUrl, params, token, accessToken);
        const boundary = this.generateBoundary();
        return this._putMultipart(url, data, extraData, accessToken, 'application/json', 'application/octet-stream', boundary);
    }
    get(url, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'GET', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req));
    }
    _post(url, data, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'POST', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req, data));
    }
    _put(url, data, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'PUT', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req, data));
    }
    _delete(url, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'DELETE', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req));
    }
    _postMultipart(url, data, extraData, token, contentType, extraType, boundary) {
        const options = this.parseUrlToOptions(url, 'POST', `multipart/form-data; boundary=${boundary}`);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallbackMultipart(req, [{ data, type: contentType }, { data: extraData, type: extraType }], boundary));
    }
    _putMultipart(url, data, extraData, token, contentType, extraType, boundary) {
        const options = this.parseUrlToOptions(url, 'PUT', `multipart/form-data; boundary=${boundary}`);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallbackMultipart(req, [{ data, type: contentType }, { data: extraData, type: extraType }], boundary));
    }
    formUrl(subUrl, params, token, accessToken) {
        return this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) + (!accessToken ? (params ? `&key=${token}` : `?key=${token}`) : '');
    }
    parseUrlToOptions(url, type, contentType) {
        const parsed = url_1.parse(url);
        return {
            hostname: parsed.hostname,
            port: parsed.port ? parsed.port : 443,
            path: parsed.path,
            method: type,
            headers: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                'Content-Type': contentType
            }
        };
    }
    generateBoundary() {
        let boundary = '--------------------------';
        for (let i = 0; i < 24; i++) {
            boundary += Math.floor(Math.random() * 10).toString(16);
        }
        return boundary;
    }
    req(options, reqFunction) {
        return new Promise((resolve, reject) => {
            const cb = (res) => {
                let data = '';
                res.setEncoding('utf8');
                res.on('data', chunk => {
                    data += chunk;
                });
                res.on('end', () => {
                    if (res.statusCode === 404) {
                        return reject(new Error('Not found'));
                    }
                    // no content
                    if (res.statusCode === 204) {
                        return resolve();
                    }
                    if (res.headers['content-type'].startsWith('application/octet-stream')) {
                        return resolve(Buffer.from(data));
                    }
                    if (!res.headers['content-type'].startsWith('application/json')) {
                        return reject('Unexpected content type: ' + res.headers['content-type'] + '\nData: ' + data);
                    }
                    let parsed;
                    try {
                        parsed = JSON.parse(data);
                    }
                    catch (err) {
                        return reject('Error parsing JSON response: ' + data);
                    }
                    if (parsed.error) {
                        return reject(new Error(parsed.error.message));
                    }
                    return resolve(parsed);
                });
                res.on('error', error => {
                    return reject(error);
                });
            };
            reqFunction(https_1.request(options, cb));
        });
    }
    reqCallback(req, data) {
        req.on('error', error => {
            throw error;
        });
        if (data) {
            req.write(data);
        }
        req.end();
    }
    reqCallbackMultipart(req, data, boundary) {
        req.on('error', error => {
            throw error;
        });
        for (let i = 0; i < data.length; i++) {
            req.write(`--${boundary}\n`);
            req.write(`Content-Disposition: form-data; name="${i}"\n`);
            req.write(`Content-Type: ${data[i].type}\n\n`);
            req.write(data[i].data);
            req.write('\n');
        }
        req.write(`--${boundary}--`);
        req.end();
    }
    parseParams(params) {
        if (!params) {
            return '';
        }
        let url = '';
        for (let param in params) {
            url += (!url.includes('?') ? '?' : '&') + param + '=' + params[param];
        }
        return url;
    }
}
exports.Request = Request;

//# sourceMappingURL=request.js.map
