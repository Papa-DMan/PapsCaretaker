"use strict";
/* istanbul ignore file */
/* We ignore this file because OAuth endpoints are too taxing to test, they are instead manually tested. */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth = void 0;
const _1 = require(".");
const constants_1 = require("./constants");
const services_1 = require("./services");
const util_1 = require("./util");
/**
 * All methods requiring an OAuth access token.
 * Use `YouTube#oauth` to access these methods.
 */
class OAuth {
    /**
     *
     * @param youtube The YouTube object to retrieve the token from.
     */
    constructor(youtube) {
        this.youtube = youtube;
    }
    /**
     * @ignore
     */
    checkTokenAndThrow() {
        if (!this.youtube.accessToken) {
            throw new Error('Must have an access token for OAuth related methods');
        }
    }
    /**
     * Gets the authorized user's [[Channel]].
     * Last tested 05/18/2020 11:48. PASSING
     */
    getMe() {
        this.checkTokenAndThrow();
        return services_1.GenericService.getItem(this.youtube, _1.Channel, true);
    }
    /**
     * Gets the authorized user's [[Subscription]]s.
     * Last tested 05/18/2020 11:48. PASSING
     * @param maxResults The maximum number of subscriptions to fetch.
     * Fetches 10 by default. Set to a value <=0 to fetch all.
     */
    getMySubscriptions(maxResults = 10) {
        this.checkTokenAndThrow();
        return services_1.GenericService.getPaginatedItems(this.youtube, 'subscriptions', true, null, maxResults);
    }
    /**
     * Gets the authorized user's [[Playlist]]s.
     * Last tested 05/18/2020 11:48. PASSING
     * @param maxResults The maximum number of playlists to fetch.
     * Fetches 10 by default. Set to a value <=0 to fetch all.
     */
    getMyPlaylists(maxResults = 10) {
        this.checkTokenAndThrow();
        return services_1.GenericService.getPaginatedItems(this.youtube, 'playlists:channel', true, null, maxResults);
    }
    /**
     * Post a [[Comment]] on a [[Video]] or [[Channel]] discussion.
     * Last tested 05/18/2020 11:48. PASSING
     * @param text The text content of the comment.
     * @param channelResolvable The channel to post the comment on.
     * @param videoResolvable The video of the channel to post the comment on.
     * If falsey, the comment will be posted to the channel discussion.
     */
    postComment(text, channelResolvable, videoResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const channelId = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = JSON.parse(JSON.stringify(constants_1.COMMENT_THREAD_DATA));
            data.snippet.topLevelComment.snippet.textOriginal = text;
            data.snippet.channelId = channelId;
            if (videoId) {
                data.snippet.videoId = videoId;
            }
            const result = yield this.youtube._request.post('commentThreads', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            const type = result.snippet.channelId ? 'channel' : 'video';
            return new _1.YTComment(this.youtube, result.snippet.topLevelComment, type);
        });
    }
    /**
     * Replies to a [[YTComment]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param commentId The ID of the comment to reply to.
     * @param text The text to reply with.
     * @param commentType What this comment is on - defaults to video.
     * Required for [[YTComment#url]] to be correct.
     */
    replyToComment(commentId, text) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.COMMENT_DATA));
            data.snippet = { parentId: commentId, textOriginal: text };
            const response = yield this.youtube._request.post('comments', { part: 'id,snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.YTComment(this.youtube, response, response.snippet.channelId ? 'channel' : 'video');
        });
    }
    /**
     * Edit a [[Comment]] on a [[Video]] or [[Channel]] discussion.
     * Last tested 05/18/2020 11:48. PASSING
     * @param text The new text content of the comment.
     * @param commentId The ID of the comment.
     */
    editComment(text, commentId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.COMMENT_THREAD_DATA));
            data.snippet.topLevelComment.snippet.textOriginal = text;
            data.id = commentId;
            const result = yield this.youtube._request.put('commentThreads', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            const type = result.snippet.channelId ? 'channel' : 'video';
            const comment = new _1.YTComment(this.youtube, result.snippet.topLevelComment, type);
            if (result.replies) {
                result.replies.comments.forEach(reply => {
                    const created = new _1.YTComment(this.youtube, reply, type);
                    comment.replies.push(created);
                });
            }
            return comment;
        });
    }
    /**
     * Edits a [[YTComment]] reply.
     * Last tested 05/18/2020 11:48. PASSING
     * @param commentId The ID of the reply to edit.
     * @param text The text to edit the reply to.
     * @param commentType What this comment is on - defaults to video.
     * Required for [[YTComment#url]] to be correct.
     */
    editCommentReply(commentId, text) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.COMMENT_DATA));
            data.id = commentId;
            data.snippet.textOriginal = text;
            const response = yield this.youtube._request.put('comments', { part: 'id,snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.YTComment(this.youtube, response, response.snippet.channelId ? 'channel' : 'video');
        });
    }
    /**
     * Marks a [[YTComment]] as spam.
     * Last tested NEVER
     * @param commentId The ID of the comment to mark as spam.
     */
    markCommentAsSpam(commentId) {
        this.checkTokenAndThrow();
        return this.youtube._request.post('comments/markAsSpam', { id: commentId }, null, null, this.youtube.accessToken);
    }
    /**
     * Sets the moderation status of a [[YTComment]]
     * Last tested NEVER
     * @param commentId The ID of the comment to set the moderation status of.
     * @param moderationStatus The moderation status to set the comment to.
     * @param banAuthor Whether or not to ban the author from making future comments.
     */
    setCommentModerationStatus(commentId, moderationStatus, banAuthor) {
        this.checkTokenAndThrow();
        const data = {
            id: commentId,
            moderationStatus
        };
        if (banAuthor) {
            data.banAuthor = banAuthor;
        }
        return this.youtube._request.post('comments/setModerationStatus', data, null, null, this.youtube.accessToken);
    }
    /**
     * Deletes a [[YTComment]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param id The ID of the comment to delete.
     */
    deleteComment(id) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('comments', { id }, null, this.youtube.accessToken);
    }
    /**
     * Subscribe to a [[Channel]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param channelResolvable The channel to subscribe to.
     * @returns A partial subscription object.
     */
    subscribeToChannel(channelResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const channelId = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            const data = JSON.parse(JSON.stringify(constants_1.SUBSCRIPTION_DATA));
            data.snippet.resourceId.channelId = channelId;
            const result = yield this.youtube._request.post('subscriptions', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Subscription(this.youtube, result);
        });
    }
    /**
     * Unsubscribe from a [[Channel]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param channelId The channel to unsubscribe from.
     */
    unsubscribeFromChannel(subscriptionId) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('subscriptions', { id: subscriptionId }, null, this.youtube.accessToken);
    }
    /**
     * Like, dislike, or remove a rating from a [[Video]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param videoResolvable The video to rate.
     * @param rating The rating to give the video.
     */
    rateVideo(videoResolvable, rating) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            return this.youtube._request.post('videos/rate', { id: videoId, rating }, null, null, this.youtube.accessToken);
        });
    }
    /**
     * Retrieve your rating on a [[Video]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param videoResolvables The video(s) to retrieve your rating from.
     */
    getMyRatings(videoResolvables) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoIds = yield Promise.all(videoResolvables.map(videoResolvable => services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video)));
            const cached = util_1.Cache.get(`get://videos/getRating/${JSON.stringify(videoIds)}`);
            if (this.youtube._shouldCache && cached) {
                return cached;
            }
            const response = yield this.youtube._request.api('videos/getRating', { id: videoIds.join(',') }, null, this.youtube.accessToken);
            this.youtube._cache(`get://videos/getRating/${JSON.stringify(videoIds)}`, response.items);
            return response.items;
        });
    }
    /**
     * Report a [[Video]] for abuse.
     * Last tested NEVER
     * @param videoResolvable The video to report.
     * @param reasonId The reason for reporting. (IDs can be found [here](https://developers.google.com/youtube/v3/docs/videoAbuseReportReasons/list))
     * @param secondaryReasonId An optional second reason for reporting.
     * @param comments Any additional information.
     * @param language The language that the reporter speaks.
     */
    reportAbuse(videoResolvable, reasonId, secondaryReasonId, comments, language) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = {
                videoId,
                reasonId
            };
            if (secondaryReasonId)
                data.secondaryReasonId = secondaryReasonId;
            if (comments)
                data.comments = comments;
            if (language)
                data.language = language;
            return this.youtube._request.post('videos/reportAbuse', null, JSON.stringify(data), null, this.youtube.accessToken);
        });
    }
    /**
     * Deletes a [[Video]].
     * Last tested NEVER
     * @param videoResolvable The video to delete.
     */
    deleteVideo(videoResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            return this.youtube._request.delete('videos', { id: videoId }, null, this.youtube.accessToken);
        });
    }
    /**
     * Updates a [[Video]].
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested NEVER
     * @param video The updated video object.
     */
    updateVideo(video) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const parts = [];
            if (video.snippet) {
                parts.push('snippet');
                if (Array.isArray(video.snippet.tags))
                    video.snippet.tags = video.snippet.tags.join(',');
            }
            if (video.status) {
                parts.push('status');
                if (video.status.publishAt instanceof Date)
                    video.status.publishAt = video.status.publishAt.toISOString();
            }
            if (video.recordingDetails) {
                parts.push('recordingDetails');
                if (video.recordingDetails.recordingDate instanceof Date) {
                    video.recordingDetails.recordingDate = video.recordingDetails.recordingDate.toISOString();
                }
            }
            if (video.localizations)
                parts.push('localizations');
            if (parts.length === 0) {
                return this.youtube.getVideo(video.id);
            }
            const response = yield this.youtube._request.put('videos', { part: parts.join(',') }, JSON.stringify(video), null, this.youtube.accessToken);
            return new _1.Video(this.youtube, response);
        });
    }
    /**
     * Sets a new [[Thumbnail]] for a [[Video]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param videoResolvable The video to set the thumbnail for.
     * @param image The image data and type to upload.
     */
    setThumbnail(videoResolvable, image) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const response = yield this.youtube._upload.imagePost('thumbnails/set', image.data, image.type, { videoId }, null, this.youtube.accessToken);
            return response.items[0];
        });
    }
    /**
     * Creates a [[Playlist]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param title A title for the playlist.
     * @param description A description of the playlist.
     * @param privacy Whether the video is private, public, or unlisted.
     * @param tags Tags pertaining to the playlist.
     * @param language The language of the playlist's default title and description.
     * @param localizations Translated titles and descriptions.
     */
    createPlaylist(title, description, privacy, tags, language, localizations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.PLAYLIST_DATA));
            const parts = ['id', 'player'];
            data.snippet = { title };
            data.snippet.defaultLanguage = language ? language : this.youtube.language;
            if (description)
                data.snippet.description = description;
            if (privacy)
                data.status = { privacyStatus: privacy };
            if (tags)
                data.snippet.tags = tags.join(',');
            if (localizations)
                data.localizations = localizations;
            if (privacy)
                parts.push('status');
            if (localizations)
                parts.push('localizations');
            const response = yield this.youtube._request.post('playlists', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Playlist(this.youtube, response);
        });
    }
    /**
     * Updates a [[Playlist]].
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested 05/18/2020 11:48. PASSING
     * @param playlistResolvable The playlist to update.
     * @param title A title for the playlist.
     * @param description A description of the playlist.
     * @param privacy Whether the video is private, public, or unlisted.
     * @param tags Tags pertaining to the playlist.
     * @param language The language of the playlist's default title and description.
     * @param localizations Translated titles and descriptions.
     */
    updatePlaylist(playlistResolvable, title, description, privacy, tags, language, localizations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, playlistResolvable, _1.Playlist);
            const data = JSON.parse(JSON.stringify(constants_1.PLAYLIST_DATA));
            const parts = ['id', 'player', 'snippet'];
            data.id = id;
            data.snippet = { title };
            data.snippet.defaultLanguage = language ? language : this.youtube.language;
            if (description)
                data.snippet.description = description;
            if (privacy)
                data.status = { privacyStatus: privacy };
            if (tags)
                data.snippet.tags = tags.join(',');
            if (localizations)
                data.localizations = localizations;
            if (privacy)
                parts.push('status');
            if (localizations)
                parts.push('localizations');
            const response = yield this.youtube._request.put('playlists', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Playlist(this.youtube, response);
        });
    }
    /**
     * Deletes a [[Playlist]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param playlistResolvable The playlist to delete.
     */
    deletePlaylist(playlistResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, playlistResolvable, _1.Playlist);
            return this.youtube._request.delete('playlists', { id }, null, this.youtube.accessToken);
        });
    }
    /**
     * Adds a [[Video]] to a [[Playlist]].
     * Last tested 05/18/2020 11:48. PASSING
     * @param playlistResolvable The playlist to add the video to.
     * @param videoResolvable The video to add to the playlist.
     * @param position The position to add the video in. Defaults to the end.
     * @param note A user-generated note on the video.
     * @returns A partial video object.
     */
    addPlaylistItem(playlistResolvable, videoResolvable, position, note) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const playlistId = yield services_1.GenericService.getId(this.youtube, playlistResolvable, _1.Playlist);
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = JSON.parse(JSON.stringify(constants_1.PLAYLIST_ITEM_DATA));
            const parts = ['id', 'snippet'];
            data.snippet.playlistId = playlistId;
            data.snippet.resourceId.videoId = videoId;
            if (position)
                data.snippet.position = position;
            if (note)
                data.contentDetails = { note };
            if (note)
                parts.push('contentDetails');
            const response = yield this.youtube._request.post('playlistItems', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Video(this.youtube, response);
        });
    }
    /**
     * Edits a playlist item.
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested 05/18/2020 11:48. PASSING
     * @param id The ID of the playlist item to edit.
     * @param playlistResolvable The playlist that the video is in.
     * @param videoResolvable The video that's in the playlist.
     * @param position The position to change the playlist item's to.
     * @param note The note to change the playlist item's to.
     * @returns A partial video object.
     */
    updatePlaylistItem(id, playlistResolvable, videoResolvable, position, note) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const playlistId = yield services_1.GenericService.getId(this.youtube, playlistResolvable, _1.Playlist);
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = JSON.parse(JSON.stringify(constants_1.PLAYLIST_ITEM_DATA));
            const parts = ['id', 'snippet'];
            data.id = id;
            data.snippet.playlistId = playlistId;
            data.snippet.resourceId.videoId = videoId;
            if (position)
                data.snippet.position = position;
            if (note)
                data.contentDetails = { note };
            if (note)
                parts.push('contentDetails');
            const response = yield this.youtube._request.put('playlistItems', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Video(this.youtube, response);
        });
    }
    /**
     * Deletes a playlist item.
     * Last tested 05/18/2020 11:48. PASSING
     * @param id The ID of the playlist item to delete.
     */
    deletePlaylistItem(id) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('playlistItems', { id }, null, this.youtube.accessToken);
    }
    /**
     * Updates a channel's branding settings.
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested NEVER
     * @param channelResolvable The channel to update the branding settings of.
     * @param brandingSettings The new branding settings.
     */
    updateChannelBranding(channelResolvable, brandingSettings) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            const data = JSON.parse(JSON.stringify(constants_1.CHANNEL_DATA));
            data.id = id;
            data.brandingSettings = brandingSettings;
            const response = yield this.youtube._request.put('channels', { part: 'brandingSettings' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Channel(this.youtube, response);
        });
    }
    /**
     * Updates a channel's localizations.
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested 05/20/2020 02:58. PASSING
     * @param channelResolvable The channel to update the localizations of.
     * @param localizations The new localizations.
     */
    updateChannelLocalizations(channelResolvable, localizations) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            const data = JSON.parse(JSON.stringify(constants_1.CHANNEL_DATA));
            data.id = id;
            data.localizations = localizations;
            const response = yield this.youtube._request.put('channels', { part: 'localizations' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Channel(this.youtube, response);
        });
    }
    /**
     * Sets a channel as made for kids or not made for kids.
     * Last tested 05/20/2020 02:58. PASSING
     * @param channelResolvable The channel to update.
     * @param madeForKids Whether or not the channel is made for kids.
     */
    setChannelMadeForKids(channelResolvable, madeForKids) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            const data = JSON.parse(JSON.stringify(constants_1.CHANNEL_DATA));
            data.id = id;
            data.status = {
                selfDeclaredMadeForKids: madeForKids
            };
            const response = yield this.youtube._request.put('channels', { part: 'status' }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.Channel(this.youtube, response);
        });
    }
    /**
     * Sets a channel's watermark.
     * Last tested 05/19/2020 18:07. PASSING
     * @param channelResolvable The channel to set the watermark for.
     * @param type The timing type of the watermark.
     * @param offset The offset, in milliseconds, from the start/end of the video to display the watermark from.
     * @param duration The duration, in millseconds, to display the watermark for.
     * @param image The watermark image.
     */
    setChannelWatermark(channelResolvable, type, offset, duration, image, imageType) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            const data = JSON.parse(JSON.stringify(constants_1.WATERMARK_DATA));
            data.timing = {
                type: type === 'fromStart' ? 'offsetFromStart' : 'offsetFromEnd',
                offsetMs: offset,
                durationMs: duration
            };
            return this.youtube._upload.multipartImagePost('watermarks/set', JSON.stringify(data), image, imageType, { channelId: id }, null, this.youtube.accessToken);
        });
    }
    /**
     * Unsets a channel's watermark.
     * Last tested 05/18/2020 18:23. PASSING
     * @param channelResolvable The channel to unset the watermark from.
     */
    unsetChannelWatermark(channelResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const id = yield services_1.GenericService.getId(this.youtube, channelResolvable, _1.Channel);
            return this.youtube._request.post('watermarks/unset', { channelId: id }, null, null, this.youtube.accessToken);
        });
    }
    /**
     * Uploads a channel banner.
     * Last tested 05/20/2020 03:17. PASSING
     * @param image The channel banner to upload.
     * @returns The URL of the uploaded banner, used as
     * [[BrandingSettings#image#bannerExternalUrl]] in [[OAuth#updateChannelBranding]]
     */
    uploadChannelBanner(image) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const response = yield this.youtube._upload.imagePost('channelBanners/insert', image.data, image.type, null, null, this.youtube.accessToken);
            return response.url;
        });
    }
    /**
     * Adds a [[ChannelSection]] to the authorized user's [[Channel]].
     * Last tested 05/24/2020 10:11. PASSING
     * @param type The type of channel section.
     * @param style The style of the channel section.
     * @param name The name of the channel section.
     * @param position The position of the channel section on the channel homepage.
     * @param language The default language of the channel section.
     * @param playlistsResolvable Any playlists in the channel section.
     * @param channelsResolvable Any channels in the channel section.
     * @param localizations Translations of the channel section's title.
     * @param targeting Targeting data for the channel section.
     */
    addChannelSection(type, style, name, language, playlistsResolvable, channelsResolvable, localizations, targeting) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.CHANNEL_SECTION_DATA));
            const parts = ['id', 'snippet'];
            data.snippet.type = type;
            data.snippet.style = style;
            if (name)
                data.snippet.title = name;
            if (language)
                data.snippet.defaultLanguage = language;
            if (playlistsResolvable || channelsResolvable)
                data.contentDetails = {};
            if (playlistsResolvable)
                data.contentDetails.playlists = yield Promise.all(playlistsResolvable.map(v => services_1.GenericService.getId(this.youtube, v, _1.Playlist)));
            if (channelsResolvable)
                data.contentDetails.channels = yield Promise.all(channelsResolvable.map(v => services_1.GenericService.getId(this.youtube, v, _1.Channel)));
            if (localizations)
                data.localizations = localizations;
            if (targeting)
                data.targeting = targeting;
            if (playlistsResolvable || channelsResolvable)
                parts.push('contentDetails');
            if (localizations)
                parts.push('localizations');
            if (targeting)
                parts.push('targeting');
            const response = yield this.youtube._request.post('channelSections', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.ChannelSection(this.youtube, response);
        });
    }
    /**
     * Updates a [[ChannelSection]].
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested 05/24/2020 10:11. PASSING
     * @param id The ID of the channel section.
     * @param type The type of channel section.
     * @param style The style of the channel section.
     * @param name The name of the channel section.
     * @param position The position of the channel section on the channel homepage.
     * @param language The default language of the channel section.
     * @param playlistsResolvable Any playlists in the channel section.
     * @param channelsResolvable Any channels in the channel section.
     * @param localizations Translations of the channel section's title.
     * @param targeting Targeting data for the channel section.
     */
    updateChannelSection(id, type, style, name, position, language, playlistsResolvable, channelsResolvable, localizations, targeting) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.CHANNEL_SECTION_DATA));
            const parts = ['id', 'snippet'];
            data.id = id;
            data.snippet.type = type;
            data.snippet.style = style;
            if (name)
                data.snippet.title = name;
            if (position)
                data.snippet.position = position;
            if (language)
                data.snippet.defaultLanguage = language;
            if (playlistsResolvable || channelsResolvable)
                data.contentDetails = {};
            if (playlistsResolvable)
                data.contentDetails.playlists = yield Promise.all(playlistsResolvable.map(v => services_1.GenericService.getId(this.youtube, v, _1.Playlist)));
            if (channelsResolvable)
                data.contentDetails.channels = yield Promise.all(channelsResolvable.map(v => services_1.GenericService.getId(this.youtube, v, _1.Channel)));
            if (localizations)
                data.localizations = localizations;
            if (targeting)
                data.targeting = targeting;
            if (playlistsResolvable || channelsResolvable)
                parts.push('contentDetails');
            if (localizations)
                parts.push('localizations');
            if (targeting)
                parts.push('targeting');
            const response = yield this.youtube._request.put('channelSections', { part: parts.join(',') }, JSON.stringify(data), null, this.youtube.accessToken);
            return new _1.ChannelSection(this.youtube, response);
        });
    }
    /**
     * Deletes a [[ChannelSection]].
     * Last tested 05/24/2020 10:11. PASSING
     * @param id The ID of the channel section.
     */
    deleteChannelSection(id) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('channelSections', { id }, null, this.youtube.accessToken);
    }
    /**
     * Get a [[Caption]] object from the ID of the caption.
     * Last tested 06/11/2020 04:50. PASSING
     * @param videoResolvable The Title, URL, or ID of the video to get the caption from.
     * @param captionId The ID of the caption.
     */
    getCaption(videoResolvable, captionId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = yield this.youtube._request.api('captions', { videoId, id: captionId, part: 'snippet' }, null, this.youtube.accessToken);
            if (!data.items || data.items.length === 0) {
                return Promise.reject('Caption not found');
            }
            return new _1.Caption(this.youtube, data.items[0]);
        });
    }
    /**
     * Gets the [[Caption]]s of a [[Video]]. Used mostly internally with [[Video#fetchCaptions]].
     * Last tested 06/11/2020 04:50. PASSING
     * @param videoResolvable The Title, URL, or ID of the video to get the captions from.
     */
    getCaptions(videoResolvable) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = yield this.youtube._request.api('captions', { videoId, part: 'snippet' }, null, this.youtube.accessToken);
            if (!data.items || data.items.length === 0) {
                return Promise.reject('Captions not found');
            }
            return data.items.map(caption => new _1.Caption(this.youtube, caption));
        });
    }
    /**
     * Uploads a [[Caption]] track for a [[Video]].
     * Last tested 06/11/2020 04:50. PASSING
     * @param videoResolvable The video to add the caption track to.
     * @param language The language that the caption track is in.
     * @param name The name of the caption track.
     * @param track The caption track to upload.
     * @param draft Whether or not the caption track is a draft. If it is, it isn't visible to users.
     */
    uploadCaption(videoResolvable, language, name, track, draft = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const videoId = yield services_1.GenericService.getId(this.youtube, videoResolvable, _1.Video);
            const data = JSON.parse(JSON.stringify(constants_1.CAPTION_DATA));
            data.snippet = {
                videoId: videoId,
                language: language,
                name: name,
                isDraft: draft
            };
            const response = yield this.youtube._upload.multipartStreamPost('captions', JSON.stringify(data), track, { part: 'snippet' }, null, this.youtube.accessToken);
            return new _1.Caption(this.youtube, response);
        });
    }
    /**
     * Edits a [[Caption]] track.
     * **If your request does not specify a value for a property that already has a value,
     * the property's existing value will be deleted.**
     * Last tested 06/11/2020 04:50. PASSING
     * @param id The ID of the caption track to edit.
     * @param track The caption track to upload.
     * @param draft Whether or not the caption track is a draft. If it is, it isn't visible to users.
     */
    updateCaption(id, track, draft = null) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkTokenAndThrow();
            const data = JSON.parse(JSON.stringify(constants_1.CAPTION_DATA));
            data.id = id;
            data.snippet = { isDraft: draft };
            let response;
            if (track) {
                if (draft !== null) {
                    response = yield this.youtube._upload.multipartStreamPut('captions', JSON.stringify(data), track, { part: 'snippet' }, null, this.youtube.accessToken);
                }
                else {
                    response = yield this.youtube._upload.streamPut('captions', track, { part: 'snippet' }, null, this.youtube.accessToken);
                }
            }
            else {
                response = yield this.youtube._request.put('captions', { part: 'snippet' }, JSON.stringify(data), null, this.youtube.accessToken);
            }
            return new _1.Caption(this.youtube, response);
        });
    }
    /**
     * Downloads a [[Caption]] track.
     * Last tested 06/11/2020 04:50. PASSING
     * @param id The ID of the caption track to download.
     * @param format The file format to download the track in.
     * @param language The language to download the track in.
     */
    downloadCaption(id, format, language) {
        this.checkTokenAndThrow();
        const params = {};
        if (format) {
            params.tfmt = format;
        }
        if (language) {
            params.tlang = language;
        }
        return this.youtube._request.api(`captions/${id}`, params, null, this.youtube.accessToken);
    }
    /**
     * Deletes a [[Caption]] track.
     * Last tested 06/11/2020 04:50. PASSING
     * @param id The ID of the caption track to delete.
     */
    deleteCaption(id) {
        this.checkTokenAndThrow();
        return this.youtube._request.delete('captions', { id }, null, this.youtube.accessToken);
    }
    /**
     * Gets a list of [[VideoAbuseReportReason]]s.
     * Last tested 05/18/2020 11:48. PASSING
     */
    getVideoAbuseReportReasons() {
        this.checkTokenAndThrow();
        return services_1.GenericService.getPaginatedItems(this.youtube, 'videoAbuseReportReasons', false);
    }
}
exports.OAuth = OAuth;

//# sourceMappingURL=oauth.js.map
